# HTTP有哪些方法？
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

# 这些方法的具体作用是什么？
GET: 通常用于请求服务器发送某些资源
HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
OPTIONS: 用于获取目的资源所支持的通信选项
POST: 发送数据给服务器
PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
DELETE: 用于删除指定的资源
PATCH: 用于对资源进行部分修改
CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
TRACE: 回显服务器收到的请求，主要用于测试或诊

# GET和POST有什么区别？✨
1. 数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。
2. 安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。
3. 数据类型不同：GET只允许 ASCII 字符，而POST无限制
4. GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单
5. 特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等

# PUT和POST都是给服务器发送新增资源，有什么区别？
PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。

除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。

# PUT和PATCH都是给服务器发送修改资源，有什么区别？
PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。

# http的请求报文是什么样的？✨
请求报文有4部分组成:
1. 请求行
2. 请求头部
3. 空行
4. 请求体

请求行包括：请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET /index.html HTTP/1.1。

请求头部:请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔
```
    User-Agent：产生请求的浏览器类型。
    Accept：客户端可识别的内容类型列表。
    Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
```

请求体: post put等请求携带的数据

参考: https://www.cxymsg.com/guide/http.html#http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F

# http的响应报文是什么样的？✨
请求报文有4部分组成:
响应行: 由协议版本，状态码和状态码的原因短语组成，例如HTTP/1.1 200 OK。
响应头: 响应部首组成
空行
响应体: 服务器响应的数据

# 聊一聊HTTP的部首有哪些？✨
通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部

+ Cache-Control  控制缓存 ✨
+ Connection 连接管理、逐条首部,浏览器想要优先使用的连接类型，比如 keep-alive ✨
+ Upgrade  升级为其他协议
+ via 代理服务器的相关信息
+ Wraning 错误和警告通知
+ Transfor-Encoding 报文主体的传输编码格式 ✨
+ Trailer 报文末端的首部一览
+ Pragma 报文指令
+ Date 创建报文的日期

请求首部字段（Reauest Header Fields）:客户端向服务器发送请求的报文时使用的首部

+ Accept 客户端或者代理能够处理的媒体类型 ✨
+ Accept-Encoding 优先可处理的编码格式
+ Accept-Language 优先可处理的自然语言
+ Accept-Charset 优先可以处理的字符集
+ If-Match 比较实体标记（ETage） ✨
+ If-None-Match 比较实体标记（ETage）与 If-Match相反 ✨
+ If-Modified-Since 比较资源更新时间（Last-Modified）✨
+ If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反 ✨
+ If-Rnages 资源未更新时发送实体byte的范围请求
+ Range 实体的字节范围请求 ✨
+ Authorization web的认证信息 ✨
+ Proxy-Authorization 代理服务器要求web认证信息
+ Host 请求资源所在服务器 ✨
+ From 用户的邮箱地址
+ User-Agent 客户端程序信息 ✨
+ Max-Forwrads 最大的逐跳次数
+ TE 传输编码的优先级
+ Referer 请求原始放的url
+ Expect 期待服务器的特定行为

响应首部字段（Response Header Fields）:从服务器向客户端响应时使用的字段

+ Accept-Ranges 能接受的字节范围
+ Age 推算资源创建经过时间
+ Location 令客户端重定向的URI ✨
+ vary  代理服务器的缓存信息
+ ETag 能够表示资源唯一资源的字符串 ✨
+ WWW-Authenticate 服务器要求客户端的验证信息
+ Proxy-Authenticate 代理服务器要求客户端的验证信息
+ Server 服务器的信息 ✨
+ Retry-After 和状态码503 一起使用的首部字段，表示下次请求服务器的时间

实体首部字段（Entiy Header Fields）:针对请求报文和响应报文的实体部分使用首部

+ Allow 资源可支持http请求的方法 ✨
+ Content-Language 实体的资源语言
+ Content-Encoding 实体的编码格式
+ Content-Length 实体的大小（字节）
+ Content-Type 实体媒体类型
+ Content-MD5 实体报文的摘要
+ Content-Location 代替资源的yri
+ Content-Rnages 实体主体的位置返回
+ Last-Modified 资源最后的修改资源 ✨
+ Expires 实体主体的过期资源 ✨


# 聊一聊HTTP的状态码

2XX 成功

+ 200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨
+ 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
+ 202 Accepted 请求已接受，但是还没执行，不保证完成请求
+ 204 No content，表示请求成功，但响应报文不含实体的主体部分
+ 206 Partial Content，进行范围请求 ✨

3XX 重定向

+ 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
+ 302 found，临时性重定向，表示资源临时被分配了新的 URL ✨
+ 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
+ 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
+ 307 temporary redirect，临时重定向，和302含义相同

4XX 客户端错误

+ 400 bad request，请求报文存在语法错误 ✨
+ 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
+ 403 forbidden，表示对请求资源的访问被服务器拒绝 ✨
+ 404 not found，表示在服务器上没有找到请求的资源 ✨
+ 408 Request timeout, 客户端请求超时
+ 409 Confict, 请求的资源可能引起冲突

5XX 服务器错误

+ 500 internal sever error，表示服务器端在执行请求时发生了错误 ✨
+ 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
+ 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
+ 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本


# 同样是重定向307，303，302的区别？
302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码又出来了两个303和307。

303明确表示客户端应当采用get方法获取资源，他会把POST请求变为GET请求进行重定向。 307会遵照浏览器标准，不会从post变为get。

# HTTP的keep-alive是干什么的？
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

keep-alive的优点：
+ 较少的CPU和内存的使用（由于同时打开的连接的减少了）
+ 允许请求和应答的HTTP管线化
+ 降低拥塞控制 （TCP连接减少了）
+ 减少了后续请求的延迟（无需再进行握手）
+ 报告错误无需关闭TCP连


# 为什么有了HTTP为什么还要HTTPS？
https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。

# HTTPS是如何保证安全的？✨
对称加密: 即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密
非对称加密: 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

TLS 握手过程
1. 客户端发送一个随机值，需要的协议和加密方式
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
3. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。

通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信

参考: https://yuchengkai.cn/docs/cs/#http-%E9%A6%96%E9%83%A8
     https://www.cxymsg.com/guide/http.html#https%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F

# HTTP2相对于HTTP1.x有什么优势和特点？
HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。

1. 二进制分帧
HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

2. 头部压缩
HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。

+ HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送
+ 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
+ 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

>你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量

3. 多路复用
HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

4. 服务器推送
服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。


# HTTP的缓存的过程是怎样的？✨
# 什么时候会触发强缓存或者协商缓存？✨
参考：https://www.jianshu.com/p/54cc04190252


***

# TCP 的特性

# 请简述TCP\UDP的区别

# 说一说OSI七层模型
物理层 => 数据链路层 => 网络层 => 传输层 => 会话层 => 表现层 => 应用层

# 讲一下三次握手？✨

# 讲一下四次握手？✨


参考：https://www.cxymsg.com/guide/tcp.html#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E2%9C%A8
     https://yuchengkai.cn/docs/cs/#%E7%8A%B6%E6%80%81%E6%9C%BA